\section{OBO Syntax}

Ian Horrocks transcribed a grammar for OBO Format 1.2. Syntax. This section borrows heavily from this work.

\subsection{Relation to OBO-Format 1.2}

OBO-Format 1.3 is forwards and backwards compatible with OBO-Format 1.2.

TODO: List of new features.

\subsection{OBO Lexical Rules}

\begin{verbatim}

OBO-Doc := header {nl}  { stanza }

header := { tagval-line }
stanza := '[' word ']' nl tagval-line { tagval-line } nl {nl}
tagval-line := 
 str-tag ':' {white} unquoted-text {white} [line-comment] nl |
 normal-tag ':' {white} obo-tokenstream [{white} xrefs] [ {white} mods] [ {white} line-comment] nl

unquoted-text := { ( char - ('!' | nl-char)) }

str-tag := 'name' | 'comment'

normal-tag := word

word := word-token { word-token }
word-token := alphanumeric | '_' | '-' 

nl := {white} [ bang-comment ] {white} nl-char
nl-char := ('\n' | '\r')
bang-comment := '!' {(char - nl-char)}

obo-tokenstream := obo-token { obo-token }
obo-token := quoted-string | bare-token

bare-token := token-char { token-char }
token-char := esc-char | char - (white | nl | '{' | '}' | '[' | ']')

esc-char := '\' char

xrefs := '[' {white} xref { {white} ',' xref } {white} ']'
mods := '{' {white} mod { {white} ',' mod } {white} '}'

line-comment := '!' { char - nl-char }

\end{verbatim}


\subsection{OBO Document Structure}

An OBO file consists of a header followed by zero or more stanzas.

\begin{verbatim}
OBO-Doc := header { stanza }
stanza := term-stanza | typedef-stanza | instance-stanza | annotation-stanza | formula-stanza
\end{verbatim}

Each stanza is associated with a single namespace. Note that a single
ID-space such as GO can have IDs dividied across multiple namespaces.

\subsection{OBO Header}

The header consists of a number of tag-value pairs, most of which we will ignore for the time being. Many of these (e.g., <remark> could clearly be treated as annotations; others (e.g., <default-namespace> correspond to parts of an XML document preamble.

\begin{verbatim}
header :=
   <format-version>
   [ <data-version> ]
   [ <date> ]
   [ <saved-by> ]
   [ <auto-generated-by> ]
   [ <subsetdef> ]
   { import }
   { <synonymtypedef> }
   { <idspace> }
   [ <default-namespace> ]
   [ <default-relationship-id> ]
   { <idmapping> }
   { expansion-macro }
   [ <remark> ]

import := 'import:' <URL>

expansion-macro :=
  'relax-unique-name-assumption-for-idspace:' idspace |
  'treat-xrefs-as-equivalent:' idspace |
  'treat-xrefs-as-is_a:' idspace |
  'treat-xrefs-as-inverted-is_a:' idspace |
  'treat-xrefs-as-genus-differentia:' idspace relation-id type-id |
  'treat-xrefs-as-relationship:' idspace relation-id
  'treat-xrefs-as-unique:' idspace

\end{verbatim}

The default-namespace specifies the default namespace for all stanzas
in that file. A namespace that is stated using the namespace tag
always takes precedence over the default-namespace tag.

Behavior is undefined if neither stanza namespace nor header
default-namespace is specified, it is recommended the parser assign a
default namespace equivalent to the path or URL from which the
ontology was downloaded.


\subsection{Term Stanzas}

Term stanzas introduce and define the meaning of types (AKA terms, concepts, classes and unary predicates).

Currently the grammar enforces an ordering of tags. This should be
changed. Tag ordering is recommended for generation, but optional for
parsing. It is strongly recommended that tags are grouped (i.e. tags
of the same type should not be separated by other tags).

\begin{verbatim}
term-stanza :=
   '[Term]'
   typeid-TVP
   name-TVP
   [ namespace-TVP ]
   { altid-TVP }
   [ def-TVP ]
   [ comment-TVP ]
   { <subset> }
   { <synonym> }
   { xref-TVP }
   { isa-TVP }
   { intersection-TVP }
   { union-TVP }
   { disjoint-TVP }
   { relationship-TVP }
   { equiv-TVP }
   { p-obj-value-TVP | p-data-value-TVP }
   [ is-obsolete-TVP ]
   [ is-anonymous-TVP ]
   [ <replaced_by> ]
   { <consider> }
   { formula-TVP }

typeid-TVP :=
   'id:' type-id
   [ 'is_anonymous: true' ]
type-id := <string>

name-TVP := 
  'name:'<string>

comment-TVP := 
  'name:'<string>

namespace-TVP :=
  'namespace:' id

xref-TVP :=
  ( 'xref:' | 'xref_analog:' ) id

def-TVP :=
  'def:' quoted-string xrefs

altid-TVP :=
  'alt_id:' id

isa-TVP :=
   'is_a:' type-id
   [ 'namespace=' <namespace-id> ]
   [ 'derived=true' | 'derived=false' ]

intersection-TVP :=
   'intersection_of:' termOrRestr
   [ 'namespace=' <namespace-id> ]
termOrRestr := type-id | restriction
restriction := relationship-id type-id
relationship-id := <string>

union-TVP :=
   'union_of:' termOrRestr
   [ 'namespace=' <namespace-id> ]

disjoint-TVP :=
   'disjoint_from:' type-id
   [ 'namespace=' <namespace-id> ]
   [ 'derived=true' | 'derived=false' ]

relationship-TVP :=
   'relationship:' restriction
   [ 'not_necessary=true' | 'not_necessary=false' ]
   [ 'inverse_necessary=true' | 'inverse_necessary=false' ]
   [ 'cardinality=' <non-neg-int> ]
   [ 'maxCardinality=' <non-neg-int> ]
   [ 'minCardinality=' <non-neg-int> ]

equiv-TVP :=
   'equivalent_to:' type-id

formula-TVP :=
   'formula:' [formula-syntax] formula-str {xref}

formula-syntax :=
   'KIF' | 'CLIF' | 'XCL' | 'Prover9'


\end{verbatim}

\subsection{Typedef Stanzas}

Typedef stanzas introduce and define the meaning of relations (AKA roles, properties and predicates).

\begin{verbatim}
typedef-stanza :=
   '[Typedef]'
   typedef-TVP
   'name:'<string>
   [ <namespace> ]
   { <alt_id> }
   [ <def> ]
   [ <comment> ]
   { <subset> }
   { <synonym> }
   { <xref> }
   [ domain-TVP ]
   [ range-TVP ]
   { unary-property-TVP }
   { r-isa-TVP }
   { r-intersection-TVP }
   [ inverse-TVP ]
   [ inst-inverse-TVP ]
   [ transover-TVP ]
   { holdsover-TVP }
   { equivchain-TVP }
   { disjover-TVP }
   { r-relationship-TVP }
   { r-equiv-TVP }
   { p-obj-value-TVP | p-data-value-TVP }
   [ is-obsolete-TVP ]
   [ <replaced_by> ]
   { <consider> }
   { formula-TVP }

typedefid-TVP :=
   'id:' relationship-id
   [ 'is_anonymous: true' ]

domain-TVP := 'domain:' termOrReserved
termOrReserved := type-id | <reserved-id>

range-TVP := 'range:' termOrReserved

unary-property-TVP :=
    unary-property ':' ( 'true' | 'false' )
unary-property :=
   'is_anti_symmetric' |
   'is_cyclic' | 
   'is_reflexive' | 
   'is_irreflexive' | 
   'is_symmetric' | 
   'is_transitive' | 
   'is_functional' | 
   'is_inverse_functional' | 
   'is_metadata_tag' 

is-obsolete-TVP := 'is_obsolete:' ( 'true' | 'false' )

r-isa-TVP := 'is_a:' relationship-id [ isa-mlist ]
isa-mlist := '{' isa-modifier { ',' isa-modifier } '}'
isa-modifier := namespace-mod | derived-mod
namespace-mod := 'namespace=' namespace-id
derived-mod := 'derived=true' | 'derived=false'

r-intersection-TVP := 'intersection_of:' relationship-id

inverse-TVP := 'inverse_of:' relationship-id
inst-inverse-TVP := 'inverse_of_on_instance_level:' relationship-id

transover-TVP := 'transitive_over:' relationship-id

holdsover-TVP := 'holds_over_chain:' relationship-id relationship-id

equivchain-TVP := 'equivalent_to_chain:' relationship-id relationship-id

disjover-TVP := 'disjoint_over:' relationship-id relationship-id

r-relationship-TVP :=
   'relationship:' r-relationship-type relationship-id

r-relationship-type := 
 'all_some_all_times' |
 'all_some' |
 'all_some_all_tr' |
 'all_only_all_times' |
 'all_only' |

r-equiv-TVP :=
   'equivalent_to:' type-id

\end{verbatim}

\subsection{Instance Stanzas}

Instance stanzas introduce and define the meaning of instances (AKA individuals, individual names, constants).

\begin{verbatim}
instance-stanza :=
   '[Instance]'
   instanceid-TVP
   'name:'<string>
   [ <namespace>]
   { <alt_id> }
   [ <comment> ]
   { <synonym> }
   { <xref> }
   'instance_of:' type-id { 'instance_of:' type-id }
   { i-relationship-TVP }
   { p-obj-value-TVP | p-data-value-TVP }
   [ is-obsolete-TVP ]
   [ <replaced_by> ]
   { <consider> }

instanceid-TVP :=
   'id:' instance-id
   [ 'is_anonymous: true' ]

p-obj-value-TVP := 'property_value:' relationship-id instance-id

p-data-value-TVP := 'property_value:' relationship-id '"' <string> '"' <XML-Schema-datatype> 

\end{verbatim}

\subsection{Annotation Stanzas}

Annotation stanzas introduce and define the meaning of annotations. In
OBO an annotation is a statement assumed to be true in some non-global
context.

\begin{verbatim}
annotation-stanza :=
   '[Annotation]'
   [annotationid-TVP]
   [ <namespace>]
   { <alt_id> }
   [ <comment> ]
   { <synonym> }
   { <xref> }
   subject-TVP
   [ is_negated-TVP ]
   relation-TVP
   object-TVP
   [ description-TVP ]
   [ assigned_by-TVP ]
   [ source-TVP ]
   [ context-TVP ]
   { evidence-TVP }
   {'instance_of:' type-id }
   { p-obj-value-TVP | p-data-value-TVP }
   [ <is_obsolete> ]
   [ <replaced_by> ]
   { <consider> }

annotationid-TVP :=
   'id:' annotation-id

subject-TVP :=
   'subject:' entity-id

is_negated-TVP :=
   'is_negated:true' | 'is_negated:false'

relation-TVP :=
   relation:' relation-id

object-TVP :=
   'object:' object-id

description-TVP :=
   'description:' desc-str

assigned_by-TVP :=
   'assigned_by:' inst-id

source-TVP :=
   'source:' inst-id

context-TVP :=
   'context:' context-id

evidence-TVP :=
   'evidence:' entity-id


\end{verbatim}

\subsection{Formula Stanzas}

Formula stanzas introduce logical formulae.

\begin{verbatim}
formula-stanza :=
   '[Formula]'
   [formulaid-TVP]
   [ <namespace>]
   { <alt_id> }
   [ <comment> ]
   { <synonym> }
   { <xref> }
   [ syntax-TVP ]
   [ description-TVP ]
   [ <is_obsolete> ]
   [ <replaced_by> ]
   { <consider> }
   formula-body-TVP

formulaid-TVP :=
   'id:' formula-id

syntax-TVP :=
   'syntax:' formula-syntax

formula-body-TVP :=
   'body:' formula-str

\end{verbatim}

\subsection{ID Macros}

\subsubsection{ID Expressions}

\begin{verbatim}
idref := id-expr
idref := identifier
id-expr := genus-id '^' differentium { '^' differentium }
differentium := rel-id '(' idref ')'
genus-id := idref
\end{verbatim}

Any time an identifier matches the above pattern, it is auto-expanded to a stanza:

\begin{verbatim}
[Term]
id: <id-expr>
intersection_of: <genus-id>
intersection_of: <rel-id1> <idref-1>
 .
 .
intersection_of: <rel-id-n> <idref-n>
\end{verbatim}

\subsubsection{Unique ID and Label Assumption}

The local unique ID and label assumption is assumed true for a namespace unless explicitly declared false.

\begin{verbatim}
'unique-id-assumption:' namespace-id ( 'true' | 'false' )
'unique-label-assumption:' namespace-id ( 'true' | 'false' )
\end{verbatim}


\subsubsection{Xref Expansion}

\begin{scriptsize}
\begin{table}
\begin{tabular}{ | p{5cm} | p{5cm} | p{5cm} |}
\hline
Header & Xref & Expansion \\

\hline
\begin{verbatim}
treat-xrefs-as-equivalent: IDSpace
\end{verbatim}
&
\begin{verbatim}
xref: IDSpace:LocalID
\end{verbatim}
&
\begin{verbatim}
equivalent_to: IDSpace:LocalID
\end{verbatim}
\\

\hline
\begin{verbatim}
treat-xrefs-as-genus-differentia: IDSpace Rel Filler
\end{verbatim}
&
\begin{verbatim}
xref: IDSpace:LocalID
\end{verbatim}
&
\begin{verbatim}
intersection_of: IDSpace:LocalID
intersection_of: Rel Filler
\end{verbatim}
\\

\hline
\begin{verbatim}
treat-xref-as-relationship: IDSpace Rel
\end{verbatim}
&
\begin{verbatim}
xref: IDSpace:LocalID
\end{verbatim}
&
\begin{verbatim}
relationship: Rel IDSpace:LocalID
\end{verbatim}
\\

\hline
\begin{verbatim}
treat-xref-as-is_a: IDSpace
\end{verbatim}
&
\begin{verbatim}
xref: IDSpace:LocalID
\end{verbatim}
&
\begin{verbatim}
is_a: IDSpace:LocalID
\end{verbatim}
\\

\hline
\begin{verbatim}
treat-xref-as-inverted-is_a: IDSpace
\end{verbatim}
&
\begin{verbatim}
id: ID
xref: IDSpace:LocalID
\end{verbatim}
&
\begin{verbatim}
id: IDSpace:LocalID
is_a: ID
\end{verbatim}
\\

\hline
\end{tabular}
\end{table}
\end{scriptsize}


\subsection{Additional considerations}
